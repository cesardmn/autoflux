class N{diff(e,n,t={}){let l;typeof t=="function"?(l=t,t={}):"callback"in t&&(l=t.callback);const s=this.castInput(e,t),u=this.castInput(n,t),r=this.removeEmpty(this.tokenize(s,t)),i=this.removeEmpty(this.tokenize(u,t));return this.diffWithOptionsObj(r,i,t,l)}diffWithOptionsObj(e,n,t,l){var s;const u=a=>{if(a=this.postProcess(a,t),l){setTimeout(function(){l(a)},0);return}else return a},r=n.length,i=e.length;let c=1,f=r+i;t.maxEditLength!=null&&(f=Math.min(f,t.maxEditLength));const g=(s=t.timeout)!==null&&s!==void 0?s:1/0,C=Date.now()+g,h=[{oldPos:-1,lastComponent:void 0}];let d=this.extractCommon(h[0],n,e,0,t);if(h[0].oldPos+1>=i&&d+1>=r)return u(this.buildValues(h[0].lastComponent,n,e));let E=-1/0,L=1/0;const j=()=>{for(let a=Math.max(E,-c);a<=Math.min(L,c);a+=2){let v;const w=h[a-1],P=h[a+1];w&&(h[a-1]=void 0);let y=!1;if(P){const O=P.oldPos-a;y=P&&0<=O&&O<r}const I=w&&w.oldPos+1<i;if(!y&&!I){h[a]=void 0;continue}if(!I||y&&w.oldPos<P.oldPos?v=this.addToPath(P,!0,!1,0,t):v=this.addToPath(w,!1,!0,1,t),d=this.extractCommon(v,n,e,a,t),v.oldPos+1>=i&&d+1>=r)return u(this.buildValues(v.lastComponent,n,e))||!0;h[a]=v,v.oldPos+1>=i&&(L=Math.min(L,a-1)),d+1>=r&&(E=Math.max(E,a+1))}c++};if(l)(function a(){setTimeout(function(){if(c>f||Date.now()>C)return l(void 0);j()||a()},0)})();else for(;c<=f&&Date.now()<=C;){const a=j();if(a)return a}}addToPath(e,n,t,l,s){const u=e.lastComponent;return u&&!s.oneChangePerToken&&u.added===n&&u.removed===t?{oldPos:e.oldPos+l,lastComponent:{count:u.count+1,added:n,removed:t,previousComponent:u.previousComponent}}:{oldPos:e.oldPos+l,lastComponent:{count:1,added:n,removed:t,previousComponent:u}}}extractCommon(e,n,t,l,s){const u=n.length,r=t.length;let i=e.oldPos,c=i-l,f=0;for(;c+1<u&&i+1<r&&this.equals(t[i+1],n[c+1],s);)c++,i++,f++,s.oneChangePerToken&&(e.lastComponent={count:1,previousComponent:e.lastComponent,added:!1,removed:!1});return f&&!s.oneChangePerToken&&(e.lastComponent={count:f,previousComponent:e.lastComponent,added:!1,removed:!1}),e.oldPos=i,c}equals(e,n,t){return t.comparator?t.comparator(e,n):e===n||!!t.ignoreCase&&e.toLowerCase()===n.toLowerCase()}removeEmpty(e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(e[t]);return n}castInput(e,n){return e}tokenize(e,n){return Array.from(e)}join(e){return e.join("")}postProcess(e,n){return e}get useLongestToken(){return!1}buildValues(e,n,t){const l=[];let s;for(;e;)l.push(e),s=e.previousComponent,delete e.previousComponent,e=s;l.reverse();const u=l.length;let r=0,i=0,c=0;for(;r<u;r++){const f=l[r];if(f.removed)f.value=this.join(t.slice(c,c+f.count)),c+=f.count;else{if(!f.added&&this.useLongestToken){let g=n.slice(i,i+f.count);g=g.map(function(C,h){const d=t[c+h];return d.length>C.length?d:C}),f.value=this.join(g)}else f.value=this.join(n.slice(i,i+f.count));i+=f.count,f.added||(c+=f.count)}}return l}}function T(o,e){let n;for(n=0;n<o.length&&n<e.length;n++)if(o[n]!=e[n])return o.slice(0,n);return o.slice(0,n)}function k(o,e){let n;if(!o||!e||o[o.length-1]!=e[e.length-1])return"";for(n=0;n<o.length&&n<e.length;n++)if(o[o.length-(n+1)]!=e[e.length-(n+1)])return o.slice(-n);return o.slice(-n)}function D(o,e,n){if(o.slice(0,e.length)!=e)throw Error(`string ${JSON.stringify(o)} doesn't start with prefix ${JSON.stringify(e)}; this is a bug`);return n+o.slice(e.length)}function S(o,e,n){if(!e)return o+n;if(o.slice(-e.length)!=e)throw Error(`string ${JSON.stringify(o)} doesn't end with suffix ${JSON.stringify(e)}; this is a bug`);return o.slice(0,-e.length)+n}function p(o,e){return D(o,e,"")}function W(o,e){return S(o,e,"")}function A(o,e){return e.slice(0,$(o,e))}function $(o,e){let n=0;o.length>e.length&&(n=o.length-e.length);let t=e.length;o.length<e.length&&(t=o.length);const l=Array(t);let s=0;l[0]=0;for(let u=1;u<t;u++){for(e[u]==e[s]?l[u]=l[s]:l[u]=s;s>0&&e[u]!=e[s];)s=l[s];e[u]==e[s]&&s++}s=0;for(let u=n;u<o.length;u++){for(;s>0&&o[u]!=e[s];)s=l[s];o[u]==e[s]&&s++}return s}function x(o){let e;for(e=o.length-1;e>=0&&o[e].match(/\s/);e--);return o.substring(e+1)}function m(o){const e=o.match(/^\s*/);return e?e[0]:""}const F="a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}",q=new RegExp(`[${F}]+|\\s+|[^${F}]`,"ug");class M extends N{equals(e,n,t){return t.ignoreCase&&(e=e.toLowerCase(),n=n.toLowerCase()),e.trim()===n.trim()}tokenize(e,n={}){let t;if(n.intlSegmenter){const u=n.intlSegmenter;if(u.resolvedOptions().granularity!="word")throw new Error('The segmenter passed must have a granularity of "word"');t=Array.from(u.segment(e),r=>r.segment)}else t=e.match(q)||[];const l=[];let s=null;return t.forEach(u=>{/\s/.test(u)?s==null?l.push(u):l.push(l.pop()+u):s!=null&&/\s/.test(s)?l[l.length-1]==s?l.push(l.pop()+u):l.push(s+u):l.push(u),s=u}),l}join(e){return e.map((n,t)=>t==0?n:n.replace(/^\s+/,"")).join("")}postProcess(e,n){if(!e||n.oneChangePerToken)return e;let t=null,l=null,s=null;return e.forEach(u=>{u.added?l=u:u.removed?s=u:((l||s)&&z(t,s,l,u),t=u,l=null,s=null)}),(l||s)&&z(t,s,l,null),e}}const J=new M;function B(o,e,n){return J.diff(o,e,n)}function z(o,e,n,t){if(e&&n){const l=m(e.value),s=x(e.value),u=m(n.value),r=x(n.value);if(o){const i=T(l,u);o.value=S(o.value,u,i),e.value=p(e.value,i),n.value=p(n.value,i)}if(t){const i=k(s,r);t.value=D(t.value,r,i),e.value=W(e.value,i),n.value=W(n.value,i)}}else if(n){if(o){const l=m(n.value);n.value=n.value.substring(l.length)}if(t){const l=m(t.value);t.value=t.value.substring(l.length)}}else if(o&&t){const l=m(t.value),s=m(e.value),u=x(e.value),r=T(l,s);e.value=p(e.value,r);const i=k(p(l,r),u);e.value=W(e.value,i),t.value=D(t.value,l,i),o.value=S(o.value,l,l.slice(0,l.length-i.length))}else if(t){const l=m(t.value),s=x(e.value),u=A(s,l);e.value=W(e.value,u)}else if(o){const l=x(o.value),s=m(e.value),u=A(l,s);e.value=p(e.value,u)}}class V extends N{constructor(){super(...arguments),this.tokenize=_}equals(e,n,t){return t.ignoreWhitespace?((!t.newlineIsToken||!e.includes(`
`))&&(e=e.trim()),(!t.newlineIsToken||!n.includes(`
`))&&(n=n.trim())):t.ignoreNewlineAtEof&&!t.newlineIsToken&&(e.endsWith(`
`)&&(e=e.slice(0,-1)),n.endsWith(`
`)&&(n=n.slice(0,-1))),super.equals(e,n,t)}}const R=new V;function Z(o,e,n){return R.diff(o,e,n)}function _(o,e){e.stripTrailingCr&&(o=o.replace(/\r\n/g,`
`));const n=[],t=o.split(/(\n|\r\n)/);t[t.length-1]||t.pop();for(let l=0;l<t.length;l++){const s=t[l];l%2&&!e.newlineIsToken?n[n.length-1]+=s:n.push(s)}return n}export{B as a,Z as d};
